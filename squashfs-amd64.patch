diff -Nur squashfs2.0.org/squashfs-tools/mksquashfs.c squashfs2.0/squashfs-tools/mksquashfs.c
--- squashfs2.0.org/squashfs-tools/mksquashfs.c	2004-05-20 22:18:12.000000000 +0000
+++ squashfs2.0/squashfs-tools/mksquashfs.c	2004-07-05 23:11:40.000000000 +0000
@@ -117,7 +117,7 @@
 
 /* fragment block data structures */
 int fragments = 0;
-static char fragment_data[SQUASHFS_FILE_MAX_SIZE];
+static char *fragment_data;
 static int fragment_size = 0;
 struct fragment {
 	unsigned int		index;
@@ -172,6 +172,16 @@
 /* flag indicating whether files are sorted using sort list(s) */
 int sorted = 0;
 
+long long global_uid = -1, global_gid = -1;
+
+/* structure to used to pass in a pointer or an integer
+ * to duplicate buffer read helper functions.
+ */
+struct duplicate_buffer_handle {
+	unsigned char	*ptr;
+	unsigned int	start;
+};
+
 struct old_root_entry_info *old_root_entry;
 void add_old_root_entry(char *name, squashfs_inode inode, int type);
 extern int read_super(int fd, squashfs_super_block *sBlk, int *be, char *source);
@@ -185,7 +195,7 @@
 squashfs_inode get_sorted_inode(struct stat *buf);
 int read_sort_file(char *filename, int source, char *source_path[]);
 void sort_files_and_write(int source, char *source_path[]);
-struct file_info *duplicate(unsigned char *(get_next_file_block)(unsigned int *, unsigned int), unsigned int file_start, int bytes, unsigned int **block_list, int *start, int blocks, struct fragment **fragment, char *frag_data, int frag_bytes);
+struct file_info *duplicate(unsigned char *(get_next_file_block)(struct duplicate_buffer_handle *, unsigned int), struct duplicate_buffer_handle *file_start, int bytes, unsigned int **block_list, int *start, int blocks, struct fragment **fragment, char *frag_data, int frag_bytes);
 
 #define FALSE 0
 
@@ -467,9 +477,9 @@
 	}
 
 	base->mode = SQUASHFS_MODE(buf.st_mode);
-	base->uid = get_uid((squashfs_uid) buf.st_uid);
+	base->uid = get_uid((squashfs_uid) global_uid == -1 ? buf.st_uid : global_uid);
 	base->inode_type = type;
-	base->guid = get_guid((squashfs_uid) buf.st_uid, (squashfs_uid) buf.st_gid);
+	base->guid = get_guid((squashfs_uid) global_uid == -1 ? buf.st_uid : global_uid, (squashfs_uid) global_gid == -1 ? buf.st_gid : global_gid);
 
 	if(type == SQUASHFS_FILE_TYPE) {
 		int i;
@@ -737,14 +747,15 @@
 		return fragment_data + fragment->offset;
 	else {
 		squashfs_fragment_entry *disk_fragment = &fragment_table[fragment->index];
-		int size = SQUASHFS_COMPRESSED_SIZE_BLOCK(disk_fragment->size), bytes = SQUASHFS_FILE_MAX_SIZE, res;
+		int size = SQUASHFS_COMPRESSED_SIZE_BLOCK(disk_fragment->size), res;
+		long bytes = block_size;
 
 		if(SQUASHFS_COMPRESSED_BLOCK(disk_fragment->size)) {
-			char cbuffer[SQUASHFS_FILE_MAX_SIZE];
+			char cbuffer[block_size];
 
 			read_bytes(fd, disk_fragment->start_block, size, cbuffer);
 
-			if((res = uncompress(buffer, (unsigned long *) &bytes, (const char *) cbuffer, size)) != Z_OK) {
+			if((res = uncompress(buffer, &bytes, (const char *) cbuffer, size)) != Z_OK) {
 				if(res == Z_MEM_ERROR)
 					BAD_ERROR("zlib::uncompress failed, not enough memory\n");
 				else if(res == Z_BUF_ERROR)
@@ -762,7 +773,7 @@
 void write_fragment()
 {
 	int compressed_size;
-	unsigned char buffer[SQUASHFS_FILE_MAX_SIZE << 1];
+	unsigned char buffer[block_size << 1];
 
 	if(fragment_size == 0)
 		return;
@@ -770,7 +781,7 @@
 	if(fragments % FRAG_SIZE == 0)
 		if((fragment_table = (squashfs_fragment_entry *) realloc(fragment_table, (fragments + FRAG_SIZE) * sizeof(squashfs_fragment_entry))) == NULL)
 			BAD_ERROR("Out of memory in fragment table\n");
-	fragment_table[fragments].size = mangle(buffer, fragment_data, fragment_size, SQUASHFS_FILE_MAX_SIZE, noF, 1);
+	fragment_table[fragments].size = mangle(buffer, fragment_data, fragment_size, block_size, noF, 1);
 	fragment_table[fragments].start_block = bytes;
 	compressed_size = SQUASHFS_COMPRESSED_SIZE_BLOCK(fragment_table[fragments].size);
 	write_bytes(fd, bytes, compressed_size, buffer);
@@ -791,7 +802,7 @@
 	if(size == 0)
 		return &empty_fragment;
 
-	if(fragment_size + size > SQUASHFS_FILE_MAX_SIZE)
+	if(fragment_size + size > block_size)
 		write_fragment();
 
 	if((ffrg = (struct fragment *) malloc(sizeof(struct fragment))) == NULL)
@@ -828,13 +839,15 @@
 
 	for(i = 0; i < meta_blocks; i++) {
 		int avail_bytes = i == meta_blocks - 1 ? frag_bytes % SQUASHFS_METADATA_SIZE : SQUASHFS_METADATA_SIZE;
-		c_byte = mangle(cbuffer + 2, buffer + i * SQUASHFS_METADATA_SIZE , avail_bytes, SQUASHFS_METADATA_SIZE, noF, 0);
+		c_byte = mangle(cbuffer + block_offset, buffer + i * SQUASHFS_METADATA_SIZE , avail_bytes, SQUASHFS_METADATA_SIZE, noF, 0);
 		if(!swap)
 			memcpy((void *) cbuffer, (void *) &c_byte, sizeof(unsigned short));
 		else
 			SQUASHFS_SWAP_SHORTS((&c_byte), cbuffer, 1);
+		if(check_data)
+			*((unsigned char *)(cbuffer + block_offset - 1)) = SQUASHFS_MARKER_BYTE;
 		list[i] = bytes;
-		compressed_size = SQUASHFS_COMPRESSED_SIZE(c_byte) + 2;
+		compressed_size = SQUASHFS_COMPRESSED_SIZE(c_byte) + block_offset;
 		write_bytes(fd, bytes, compressed_size, cbuffer);
 		bytes += compressed_size;
 	}
@@ -854,19 +867,19 @@
 }
 
 
-unsigned char *read_from_buffer(unsigned int *start, unsigned int avail_bytes)
+unsigned char *read_from_buffer(struct duplicate_buffer_handle *handle, unsigned int avail_bytes)
 {
-	unsigned char *v = (unsigned char *) *start;
-	*start += avail_bytes;	
+	unsigned char *v = handle->ptr;
+	handle->ptr += avail_bytes;	
 	return v;
 }
 
 
 char read_from_file_buffer[SQUASHFS_FILE_MAX_SIZE];
-unsigned char *read_from_file(unsigned int *start, unsigned int avail_bytes)
+unsigned char *read_from_file(struct duplicate_buffer_handle *handle, unsigned int avail_bytes)
 {
-	read_bytes(fd, *start, avail_bytes, read_from_file_buffer);
-	*start += avail_bytes;
+	read_bytes(fd, handle->start, avail_bytes, read_from_file_buffer);
+	handle->start += avail_bytes;
 	return read_from_file_buffer;
 }
 
@@ -874,13 +887,14 @@
 /*
  * Compute 16 bit BSD checksum over the data
  */
-unsigned short get_checksum(unsigned char *(get_next_file_block)(unsigned int *, unsigned int), unsigned int file_start, int l)
+unsigned short get_checksum(unsigned char *(get_next_file_block)(struct duplicate_buffer_handle *, unsigned int), struct duplicate_buffer_handle *handle, int l)
 {
 	unsigned short chksum = 0;
-	unsigned int bytes = 0, position = file_start;
+	unsigned int bytes = 0;
 	unsigned char *b;
+	struct duplicate_buffer_handle position = *handle;
 
-	while(l--) {
+	while(l) {
 		bytes = l > SQUASHFS_FILE_MAX_SIZE ? SQUASHFS_FILE_MAX_SIZE : l;
 		l -= bytes;
 		b = get_next_file_block(&position, bytes);
@@ -900,6 +914,7 @@
 	struct fragment *frg;
 	struct file_info *dupl_ptr;
 	char *datap;
+	struct duplicate_buffer_handle handle;
 	
 	if(!duplicate_checking)
 		return;
@@ -914,16 +929,18 @@
 		datap = fragment_data + offset;
 	else
 		datap = get_fragment(fragment_data, frg);
-	if((dupl_ptr = duplicate(read_from_file, start, file_bytes, &block_listp, &start, blocks, &frg, datap, bytes)) != NULL)
+	handle.start = start;
+	if((dupl_ptr = duplicate(read_from_file, &handle, file_bytes, &block_listp, &start, blocks, &frg, datap, bytes)) != NULL)
 		dupl_ptr->fragment = frg;
 	cached_frag = fragment;
 }
 
 
-struct file_info *duplicate(unsigned char *(get_next_file_block)(unsigned int *, unsigned int), unsigned int file_start, int bytes, unsigned int **block_list, int *start, int blocks, struct fragment **fragment, char *frag_data, int frag_bytes)
+struct file_info *duplicate(unsigned char *(get_next_file_block)(struct duplicate_buffer_handle *, unsigned int), struct duplicate_buffer_handle *file_start, int bytes, unsigned int **block_list, int *start, int blocks, struct fragment **fragment, char *frag_data, int frag_bytes)
 {
 	unsigned short checksum = get_checksum(get_next_file_block, file_start, bytes);
-	unsigned short fragment_checksum = get_checksum(read_from_buffer, (unsigned int) frag_data, frag_bytes);
+	struct duplicate_buffer_handle handle = { frag_data, 0 };
+	unsigned short fragment_checksum = get_checksum(read_from_buffer, &handle, frag_bytes);
 	struct file_info *dupl_ptr = bytes ? dupl[checksum] : frag_dups[fragment_checksum];
 
 
@@ -931,7 +948,7 @@
 		if(bytes == dupl_ptr->bytes && frag_bytes == dupl_ptr->fragment->size && fragment_checksum == dupl_ptr->fragment_checksum) {
 			unsigned char buffer1[SQUASHFS_FILE_MAX_SIZE];
 			unsigned int dup_bytes = dupl_ptr->bytes, dup_start = dupl_ptr->start;
-			unsigned int position = file_start;
+			struct duplicate_buffer_handle position = *file_start;
 			unsigned char *buffer;
 			while(dup_bytes) {
 				int avail_bytes = dup_bytes > SQUASHFS_FILE_MAX_SIZE ? SQUASHFS_FILE_MAX_SIZE : dup_bytes;
@@ -944,7 +961,7 @@
 				dup_start += avail_bytes;
 			}
 			if(dup_bytes == 0) {
-				char frag_buffer1[SQUASHFS_FILE_MAX_SIZE];
+				char frag_buffer1[block_size];
 				char *fragment_buffer1 = get_fragment(frag_buffer1, dupl_ptr->fragment);
 				if(frag_bytes == 0 || memcmp(frag_data, fragment_buffer1, frag_bytes) == 0) {
 					TRACE("Found duplicate file, start 0x%x, size %d, checksum 0x%x, fragment %d, size %d, offset %d, checksum 0x%x\n", dupl_ptr->start,
@@ -996,6 +1013,7 @@
 	int allocated_blocks = blocks, i, bbytes, whole_file = 1;
 	struct fragment *fragment;
 	struct file_info *dupl_ptr;
+	struct duplicate_buffer_handle handle;
 
 	if(!no_fragments && (read_size < block_size || always_use_fragments)) {
 		allocated_blocks = blocks = read_size >> block_log;
@@ -1043,18 +1061,22 @@
 
 	close(file);
 	if(whole_file) {
-		if(duplicate_checking && (dupl_ptr = duplicate(read_from_buffer, (unsigned int) c_buffer, file_bytes, &block_listp, &start, blocks, &fragment, buff, frag_bytes)) == NULL) {
+		handle.ptr = c_buffer;
+		if(duplicate_checking && (dupl_ptr = duplicate(read_from_buffer, &handle, file_bytes, &block_listp, &start, blocks, &fragment, buff, frag_bytes)) == NULL) {
 			*duplicate_file = TRUE;
 			goto wr_inode;
 		}
 		write_bytes(fd, bytes, file_bytes, c_buffer);
 		bytes += file_bytes;
-	} else if(duplicate_checking && (dupl_ptr = duplicate(read_from_file, start, file_bytes, &block_listp, &start, blocks, &fragment, buff, frag_bytes)) == NULL) {
-		bytes = start;
-		if(!block_device)
-			ftruncate(fd, bytes);
-		*duplicate_file = TRUE;
-		goto wr_inode;
+	} else {
+		handle.start = start;
+		if(duplicate_checking && (dupl_ptr = duplicate(read_from_file, &handle, file_bytes, &block_listp, &start, blocks, &fragment, buff, frag_bytes)) == NULL) {
+			bytes = start;
+			if(!block_device)
+				ftruncate(fd, bytes);
+			*duplicate_file = TRUE;
+			goto wr_inode;
+		}
 	}
 
 	fragment = get_and_fill_fragment(buff, frag_bytes);
@@ -1415,7 +1437,7 @@
 
 
 #define VERSION() \
-	printf("mksquashfs version 2.0-ALPHA\n");\
+	printf("mksquashfs version 2.0\n");\
 	printf("copyright (C) 2004 Phillip Lougher (plougher@users.sourceforge.net)\n\n"); \
     	printf("This program is free software; you can redistribute it and/or\n");\
 	printf("modify it under the terms of the GNU General Public License\n");\
@@ -1451,7 +1473,6 @@
 	source = i - 2;
 	for(; i < argc; i++) {
 		if(strcmp(argv[i], "-b") == 0) {
-			BAD_ERROR("changing the block size is not supported in this the ALPHA version of Squashfs 2.0!!\n");
 			if((++i == argc) || (block_size = strtol(argv[i], &b, 10), *b !='\0')) {
 				ERROR("%s: -b missing or invalid block size\n", argv[0]);
 				exit(1);
@@ -1480,6 +1501,48 @@
 				ERROR("%s: -sort missing filename\n", argv[0]);
 				exit(1);
 			}
+		} else if(strcmp(argv[i], "-all-root") == 0 ||
+				strcmp(argv[i], "-root-owned") == 0)
+			global_uid = global_gid = 0;
+
+		else if(strcmp(argv[i], "-force-uid") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -force-uid missing uid or user\n", argv[0]);
+				exit(1);
+			}
+			if((global_uid = strtoll(argv[i], &b, 10)), *b =='\0') {
+				if(global_uid < 0 || global_uid > (((long long) 1 << 32) - 1)) {
+					ERROR("%s: -force-uid uid out of range\n", argv[0]);
+					exit(1);
+				}
+			} else {
+				struct passwd *uid = getpwnam(argv[i]);
+				if(uid)
+					global_uid = uid->pw_uid;
+				else {
+					ERROR("%s: -force-uid invalid uid or unknown user\n", argv[0]);
+					exit(1);
+				}
+			}
+		} else if(strcmp(argv[i], "-force-gid") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -force-gid missing gid or group\n", argv[0]);
+				exit(1);
+			}
+			if((global_gid = strtoll(argv[i], &b, 10)), *b =='\0') {
+				if(global_gid < 0 || global_gid > (((long long) 1 << 32) - 1)) {
+					ERROR("%s: -force-gid gid out of range\n", argv[0]);
+					exit(1);
+				}
+			} else {
+				struct group *gid = getgrnam(argv[i]);
+				if(gid)
+					global_gid = gid->gr_gid;
+				else {
+					ERROR("%s: -force-gid invalid gid or unknown group\n", argv[0]);
+					exit(1);
+				}
+			}
 		} else if(strcmp(argv[i], "-noI") == 0 ||
 				strcmp(argv[i], "-noInodeCompression") == 0)
 			noI = TRUE;
@@ -1638,6 +1701,9 @@
 		else if(strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "-root-becomes") == 0 || strcmp(argv[i], "-ef") == 0)
 			i++;
 
+	if((fragment_data = (char *) malloc(block_size)) == NULL)
+		BAD_ERROR("Out of memory allocating fragment_data");
+
 	if(delete) {
 		printf("Creating %s filesystem on %s, block size %d.\n",
 				be ? "big endian" : "little endian", argv[source + 1], block_size);
diff -Nur squashfs2.0.org/squashfs-tools/read_fs.c squashfs2.0/squashfs-tools/read_fs.c
--- squashfs2.0.org/squashfs-tools/read_fs.c	2004-05-18 23:17:29.000000000 +0000
+++ squashfs2.0/squashfs-tools/read_fs.c	2004-07-05 23:12:26.000000000 +0000
@@ -66,12 +66,13 @@
 		offset = 3;
 	if(SQUASHFS_COMPRESSED(c_byte)) {
 		unsigned char buffer[SQUASHFS_METADATA_SIZE];
-		int bytes = SQUASHFS_METADATA_SIZE, res;
+		int res;
+		long bytes = SQUASHFS_METADATA_SIZE;
 
 		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
 		read_bytes(fd, start + offset, c_byte, buffer);
 
-		if((res = uncompress(block, (unsigned long *) &bytes, (const char *) buffer, c_byte)) != Z_OK) {
+		if((res = uncompress(block, &bytes, (const char *) buffer, c_byte)) != Z_OK) {
 			if(res == Z_MEM_ERROR)
 				ERROR("zlib::uncompress failed, not enough memory\n");
 			else if(res == Z_BUF_ERROR)
@@ -420,7 +421,7 @@
 	printf("Read existing filesystem, %d inodes scanned\n", files);
 
 	if(inode.inode_type == SQUASHFS_DIR_TYPE) {
-		if((directory_table = squashfs_readdir(fd, !((int) root_name), sBlk->directory_table_start + inode.start_block,
+		if((directory_table = squashfs_readdir(fd, !root_name, sBlk->directory_table_start + inode.start_block,
 						inode.offset, inode.file_size, sBlk, push_directory_entry)) == NULL) {
 			ERROR("read_filesystem: Could not read root directory\n");
 			goto error;
diff -Nur squashfs2.0.org/squashfs-tools/squashfs_fs.h squashfs2.0/squashfs-tools/squashfs_fs.h
--- squashfs2.0.org/squashfs-tools/squashfs_fs.h	2004-05-18 23:20:39.000000000 +0000
+++ squashfs2.0/squashfs-tools/squashfs_fs.h	2004-07-05 23:09:32.000000000 +0000
@@ -149,7 +149,7 @@
 	unsigned int		flags:8;
 	unsigned int		no_uids:8;
 	unsigned int		no_guids:8;
-	time_t			mkfs_time /* time of filesystem creation */;
+	unsigned int		mkfs_time /* time of filesystem creation */;
 	squashfs_inode		root_inode;
 	unsigned int		block_size;
 	unsigned int		fragments;
@@ -187,7 +187,7 @@
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:8; /* index into uid table */
 	unsigned int		guid:8; /* index into guid table */
-	time_t			mtime;
+	unsigned int		mtime;
 	squashfs_block		start_block;
 	unsigned int		fragment;
 	unsigned int		offset;
@@ -202,7 +202,7 @@
 	unsigned int		guid:8; /* index into guid table */
 	unsigned int		file_size:19;
 	unsigned int		offset:13;
-	time_t			mtime;
+	unsigned int		mtime;
 	unsigned int		start_block:24;
 } __attribute__  ((packed)) squashfs_dir_inode_header;
 
@@ -388,7 +388,7 @@
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:4; /* index into uid table */
 	unsigned int		guid:4; /* index into guid table */
-	time_t			mtime;
+	unsigned int		mtime;
 	squashfs_block		start_block;
 	unsigned int		file_size:SQUASHFS_MAX_FILE_SIZE_LOG;
 	unsigned short		block_list[0];
@@ -401,7 +401,7 @@
 	unsigned int		guid:4; /* index into guid table */
 	unsigned int		file_size:19;
 	unsigned int		offset:13;
-	time_t			mtime;
+	unsigned int		mtime;
 	unsigned int		start_block:24;
 } __attribute__  ((packed)) squashfs_dir_inode_header_1;
 
